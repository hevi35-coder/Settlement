{
  "rules": [
    {
      "type": "prd",
      "content": "PRD: 월말정산 자동화 대시보드 (Final Ver. 1.1)\n1. 개요 (Overview)\n * 1.1. 목표 요약 (Goal Summary)\n   * 매월 뱅크샐러드 엑셀 파일을 업로드하여 공용지출 내역을 자동으로 추출하고, 사용자가 설정한 월급 및 고정지출액을 바탕으로 가족 계좌에 이체할 최종 금액을 계산해주는 개인용 서버리스 웹 애플리케이션을 개발한다. 이를 통해 수동 정산에 소요되는 시간을 30분에서 5분 이내로 단축시킨다.\n * 1.2. 타겟 사용자 (User Persona)\n   * 매월 월급에서 공용 생활비를 정산하여 가족에게 이체하는, 효율적이고 정확한 가계 관리를 원하는 개인 사용자.\n2. 기능 요구사항 (Functional Requirements)\n * 2.1. 사용자 스토리 (User Stories)\n   * As a user, I want to 엑셀(.xlsx)이 포함된 압축파일(.zip)을 업로드하여 so that 시스템이 내 지출 내역을 자동으로 읽고 처리할 수 있다.\n   * As a user, I want to 월급과 매달 고정적으로 나가는 지출액을 미리 설정하여 so that 매번 같은 금액을 입력할 필요 없이 자동으로 계산에 반영할 수 있다.\n   * As a user, I want to 특정 기간(시작일, 종료일)을 지정하여 so that 해당 기간의 지출 내역 전체를 불러올 수 있다.\n   * As a user, I want to 대시보드에서 최종 이체 금액과 그 계산 과정을 한눈에 확인하여 so that 이번 달에 얼마를 보내야 할지 즉시 알 수 있다.\n   * As a user, I want to 전체 지출 목록에서 공용지출 항목을 직접 선택(체크)하여 so that 최종 계산 금액에 유연하게 반영할 수 있다.\n   * As a user, I want to 월말 정산이 끝나면 [확정] 버튼을 눌러 so that 해당 월의 정산 내역을 기록하고 나중에 찾아볼 수 있다.\n   * As a user, I want to 과거에 정산했던 내역들을 목록으로 조회하여 so that 월별 지출 추이를 파악할 수 있다.\n * 2.2. 기능별 상세 명세 (Feature Specifications)\n   * 2.2.1. 데이터 처리\n     * 파일 업로드: 사용자는 웹페이지의 파일 업로드 컴포넌트를 통해 .zip 파일을 업로드한다.\n     * 압축 해제: 시스템은 업로드된 zip 파일을 사전에 설정된 비밀번호를 사용해 자동으로 압축 해제한다.\n     * 엑셀 파싱: 압축 해제된 엑셀(.xlsx) 파일에서 '가계부 내역' 시트를 읽는다.\n     * 데이터 추출: 사용자가 지정한 기간 내의 모든 지출 내역 데이터를 추출한다. 추출 대상 열은 날짜, 타입, 대분류, 소분류, 내용, 금액, 메모, 결제수단이다.\n     * 데이터 저장: 추출된 데이터는 중복을 확인하여 데이터베이스에 신규 내역만 저장한다.\n   * 2.2.2. 메인 대시보드 (정산 페이지)\n     * 상단: 최종 계산 결과(가족계좌 입금액)와 그 산식(월급 - 고정이체액 - 공용지출 합계)이 표시된다.\n     * 중단 (지출 목록): 데이터베이스에서 불러온 전체 지출 내역이 리스트 형태로 표시된다. 기본 표시 항목은 체크박스, 날짜, 타입, 내용, 금액, 메모이다. 모든 항목은 기본적으로 체크 해제 상태이며, 사용자가 항목을 체크 상태로 변경하면 상단 금액이 실시간으로 재계산된다. 사용자는 [확정] 버튼을 누르기 전까지 자유롭게 체크 상태를 수정할 수 있다. 각 항목의 메모란은 직접 입력 및 수정이 가능하며, 메모를 입력하면 해당 항목은 자동으로 체크 상태로 변경된다. 각 항목 클릭 시 전체 상세 정보를 담은 팝업(Modal)이 표시된다.\n     * 하단 (액션 버튼): [추가] 버튼을 통해 수동으로 지출 내역을 임시 추가할 수 있다. [확정] 버튼을 통해 현재 정산 내역을 '정산 이력'으로 저장한다.\n   * 2.2.3. 설정 페이지\n     * 월급액, 고정이체액, 데이터 수집 기간(시작일/종료일)을 입력하고 저장하는 기능을 제공한다.\n   * 2.2.4. 정산 이력 페이지\n     * 과거에 [확정]된 정산 내역들이 최신순으로 요약(확정일, 월급, 고정이체액, 공용지출 합계, 최종 이체액)되어 표시된다. 각 이력 클릭 시 해당 정산에 포함되었던 상세 지출 목록을 조회할 수 있다.\n * 2.3. 엣지 케이스 및 예외 처리 (Edge Cases & Error Handling)\n   * 파일 업로드 실패: 비밀번호가 틀리거나 지원하지 않는 파일 형식인 경우, \"파일 처리 실패\" 관련 오류 메시지를 사용자에게 표시한다.\n   * 엑셀 파싱 실패: '가계부 내역' 시트 또는 필수 데이터 열을 찾을 수 없는 경우, \"엑셀 형식이 올바르지 않습니다.\" 오류 메시지를 사용자에게 표시한다.\n   * 데이터 없음: 지정된 기간 내에 조건에 맞는 데이터가 없는 경우, \"해당 기간에 조회된 지출 내역이 없습니다.\" 메시지를 표시한다.\n * 2.4. 향후 확장 가능성 (Future Possibilities)\n   * 사용자 인증: Supabase 인증 기능을 활용하여 이메일/비밀번호 또는 소셜 로그인 기능을 추가한다.\n   * 다중 사용자 지원: 사용자 인증을 기반으로 가족 구성원 각자가 서비스를 사용하고 데이터를 관리하는 기능으로 확장한다.\n   * 실시간 동기화: Supabase의 실시간 기능을 이용해 여러 사용자의 데이터 변경 사항을 동기화하는 기능을 추가한다.\n   * 정산 이력 수정: 확정된 정산 이력에 대해 금액, 메모 등을 수정하거나 이력 자체를 삭제하는 기능을 추가한다.\n3. 비기능적 요구사항 (Non-Functional Requirements)\n * 3.1. 성능 (Performance)\n   * Vercel의 글로벌 엣지 네트워크를 통해 전 세계 어디서든 1초 이내의 빠른 페이지 로딩 속도를 목표로 한다.\n   * 데이터 재계산 및 UI 업데이트는 즉각적으로 반응해야 한다.\n * 3.2. 보안 (Security)\n   * Supabase의 RLS(Row Level Security)를 적용하여 사용자별 데이터 접근을 엄격히 통제한다.\n   * Vercel이 제공하는 자동 HTTPS 및 보안 기능을 기본으로 활용한다.\n   * 모든 민감 정보(API 키, 비밀번호)는 환경 변수를 통해 안전하게 관리한다.\n * 3.3. 확장성 (Scalability)\n   * 서버리스 아키텍처를 기반으로 하므로, 향후 사용자가 증가하더라도 별도의 서버 작업 없이 안정적으로 서비스를 운영할 수 있다.\n * 3.4. UI/UX\n   * 모바일 환경에서 우선적으로 사용성을 보장하는 반응형 디자인을 적용한다.\n * 3.5. 데이터 스키마 (Data Schema)\n   * 데이터베이스는 Supabase(PostgreSQL)에 생성된다. 상세 스키마는 관련 기술 문서(TRD)를 따른다.\n4. 성공 기준 (Success Metrics)\n * 본 서비스를 통해 월말 수동 정산에 소요되는 시간이 기존 30분에서 5분 이내로 단축된다.\n5. 검수 기준 (Acceptance Criteria)\n * 정상적인 뱅크샐러드 zip 파일을 업로드하면, 지정된 기간의 모든 지출 내역이 화면에 표시된다.\n * [설정] 페이지에서 저장한 월급과 고정이체액이 메인 대시보드 계산에 정확히 반영된다.\n * 지출 목록의 항목을 체크하면, 상단의 합계 금액과 최종 이체액이 실시간으로 변경된다.\n * 지출 목록 항목의 메모를 직접 수정하면, 해당 항목이 자동으로 체크되며 계산에 반영된다.\n * [확정] 버튼을 누르면, 현재 정산 내역이 [정산 이력] 페이지에 저장되고 조회할 수 있다.\n * 잘못된 파일을 올리면, 적절한 오류 메시지가 사용자에게 표시된다.\n * 모바일 화면에서도 레이아웃이 깨지지 않고 모든 기능을 정상적으로 사용할 수 있다.\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "architecture",
      "content": "TRD: 월말정산 자동화 대시보드 \n1. 시스템 아키텍처 (System Architecture)\n * 통합 프레임워크: Next.js (React 기반) - UI(프론트엔드)와 API(백엔드) 통합 관리\n * 배포/실행 환경: Vercel - Next.js 애플리케이션 배포 및 서버리스 함수 실행\n * 데이터베이스 & BaaS: Supabase - PostgreSQL 데이터베이스, 데이터 API, 인증 기능 제공\n작동 흐름:\n * 사용자 접속: 사용자는 Vercel에 배포된 Next.js 웹 앱에 접속합니다.\n * 파일 업로드: 사용자가 zip 파일을 업로드하면, Next.js API Route (/api/upload)가 Vercel 서버리스 함수로 실행됩니다.\n * 데이터 처리 및 저장: API 함수는 파일을 처리하여 Supabase 데이터베이스에 저장합니다.\n * 데이터 조회 및 표시: 사용자의 화면(클라이언트)은 Supabase에서 지정된 기간의 모든 지출 내역을 조회하여 화면에 렌더링합니다.\n2. 기술 스택 (Tech Stack)\n * 프레임워크: Next.js 14+ (App Router 권장)\n * UI: Shadcn/ui\n   * 설명: UI 라이브러리가 아닌, 재사용 가능한 컴포넌트 모음입니다. CLI를 통해 필요한 컴포넌트의 코드를 프로젝트에 직접 추가하는 방식입니다.\n   * 기반 기술: Tailwind CSS (스타일링), Radix UI (동작 및 접근성), Lucide React (아이콘)\n * 백엔드: Vercel Serverless Functions (Node.js 런타임)\n * 데이터베이스: Supabase (PostgreSQL)\n * 핵심 라이브러리:\n   * @supabase/supabase-js: Supabase DB 연동 클라이언트\n   * jszip: ZIP 파일 처리\n   * xlsx: 엑셀(.xlsx) 파일 파싱\n   * swr 또는 react-query: 클라이언트 사이드 데이터 Fetching 및 상태 관리\n3. 데이터 모델 (Data Model)\nSupabase 대시보드에서 생성할 테이블 구조입니다. (이전 버전과 동일)\n-- 사용자 설정 (향후 인증 기능 도입 시 사용)\nCREATE TABLE public.settings (\n    id UUID PRIMARY KEY DEFAULT auth.uid(),\n    salary INT DEFAULT 0,\n    fixed_expense INT DEFAULT 0\n);\n\n-- 공용지출 원본 데이터\nCREATE TABLE public.shared_expenses (\n    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    expense_date DATE NOT NULL,\n    type TEXT,\n    category_main TEXT,\n    category_sub TEXT,\n    content TEXT NOT NULL,\n    amount INT NOT NULL,\n    memo TEXT,\n    payment_method TEXT,\n    unique_hash TEXT UNIQUE NOT NULL, -- 중복 저장을 방지하기 위한 해시값\n    created_at TIMESTAMPTZ DEFAULT now()\n);\n\n-- 정산 이력 요약\nCREATE TABLE public.calculation_history (\n    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    confirmed_at TIMESTAMPTZ DEFAULT now(),\n    salary_snapshot INT NOT NULL,\n    fixed_expense_snapshot INT NOT NULL,\n    shared_expense_total INT NOT NULL,\n    final_transfer_amount INT NOT NULL,\n    details_snapshot JSONB -- 정산에 포함된 상세 내역 (수정된 메모 포함)\n);\n\n4. API 엔드포인트 명세 (API Endpoint Specifications)\nNext.js API Routes로 구현됩니다. (이전 버전과 동일)\n| 기능 | HTTP Method | Endpoint | Request | Response |\n|---|---|---|---|---|\n| 파일 업로드 및 처리 | POST | /api/upload | FormData (zip 파일) | {\"message\": \"신규 내역 N건 처리 완료\"} 또는 에러 메시지 |\n| 기간별 지출 조회 | GET | /api/expenses | Query: startDate, endDate | [{\"id\": 1, \"expense_date\": ...}] 또는 에러 메시지 |\n| 정산 내역 확정 | POST | /api/history | Body: { \"summary\": {...}, \"details\": [...] } | {\"message\": \"정산 내역 저장 완료\"} 또는 에러 메시지 |\n5. 핵심 로직 구현 상세 (Core Logic Implementation)\n5.1. 백엔드 로직 (Vercel Serverless Functions)\n * 파일 처리 로직 (/api/upload): (이전 버전과 동일)\n   * API는 multipart/form-data 형식으로 zip 파일을 수신합니다.\n   * 환경 변수에 저장된 비밀번호를 사용하여 jszip 라이브러리로 메모리상에서 압축을 해제합니다.\n   * 압축 해제된 .xlsx 파일을 찾아 xlsx 라이브러리로 파싱하여 JSON 데이터로 변환합니다.\n   * 각 데이터 행(row)에 대해 unique_hash (예: hash(날짜+내용+금액))를 생성합니다.\n   * Supabase Admin 클라이언트를 사용하여 upsert 기능으로 unique_hash 기준 중복되지 않은 데이터만 shared_expenses 테이블에 저장합니다.\n * 지출 내역 조회 로직 (/api/expenses): (이전 버전과 동일)\n   * startDate, endDate 쿼리 파라미터를 수신합니다.\n   * Supabase 클라이언트를 사용하여 shared_expenses 테이블에서 expense_date가 두 날짜 사이에 있는 모든 레코드를 조회하여 반환합니다.\n5.2. 프론트엔드 로직 (React / Shadcn/ui)\n * 데이터 상태 관리: (이전 버전과 동일)\n   * API로 조회한 지출 내역 배열을 React 상태(state)로 관리합니다.\n   * 각 지출 항목 객체는 ...originalData, isChecked: false, currentMemo: originalData.memo || '' 와 같은 구조를 가집니다.\n * UI 컴포넌트 구현 (Shadcn/ui):\n   * 지출 목록: Shadcn/ui의 Table 컴포넌트를 사용합니다. (Table, TableHeader, TableRow, TableHead, TableBody, TableCell)\n   * 체크박스: 각 행의 첫 번째 셀에 Checkbox 컴포넌트를 사용합니다.\n   * 메모 입력: 메모 셀 내부에 Input 컴포넌트를 배치하여 인라인(in-line) 수정을 구현합니다.\n   * 상세 정보 팝업: 각 행 클릭 시 Dialog 컴포넌트(DialogTrigger, DialogContent 등)를 사용하여 상세 정보를 표시합니다.\n * 사용자 인터랙션 및 계산 로직:\n   * 초기 상태: 모든 항목의 체크박스는 체크 해제 상태로 렌더링됩니다.\n   * 체크박스 클릭: onCheckedChange 이벤트 발생 시, 해당 항목의 isChecked 상태를 토글하고, 즉시 전체 합산 금액을 재계산하여 화면을 업데이트합니다.\n   * 메모 수정: 메모 Input의 onChange 이벤트 발생 시, 아래 두 가지 상태 업데이트를 동시에 수행합니다.\n     * 해당 항목의 currentMemo 상태를 사용자 입력값으로 변경합니다.\n     * 해당 항목의 isChecked 상태를 true로 강제 변경합니다.\n   * 합산 금액 계산: 전체 상태 배열에서 isChecked가 true인 항목만 필터링하여 amount의 총합을 계산하고, 이 값을 화면 상단에 실시간으로 표시합니다.\n5.3. 에러 처리 로직\n * 백엔드: (이전 버전과 동일) 파일 처리 중 예외 발생 시, 400 Bad Request 또는 500 Internal Server Error 상태 코드와 함께 에러 메시지 JSON을 반환합니다.\n * 프론트엔드: API 호출의 catch 구문에서 에러를 처리합니다. Shadcn/ui의 Toast (useToast 훅과 Toaster 컴포넌트)를 사용하여 사용자에게 직관적인 에러 메시지를 표시합니다.\n6. 배포 방안 (Deployment Plan)\n * 플랫폼: Vercel\n * 프로세스: GitHub 저장소를 Vercel 프로젝트에 연결하여 main 브랜치에 Push 할 때마다 자동 배포(CI/CD)를 구성합니다.\n * 환경 변수: Vercel 프로젝트의 'Environment Variables'에 아래 값들을 반드시 설정합니다.\n   * NEXT_PUBLIC_SUPABASE_URL: Supabase 프로젝트 URL\n   * NEXT_PUBLIC_SUPABASE_ANON_KEY: Supabase 익명 키 (클라이언트용)\n   * SUPABASE_SERVICE_ROLE_KEY: Supabase 서비스 키 (서버용)\n   * ZIP_PASSWORD: 엑셀 파일의 압축 비밀번호\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "guideline",
      "content": "# 월말정산 자동화 대시보드 코드 가이드라인\n\n본 문서는 '월말정산 자동화 대시보드' 프로젝트의 코드 품질, 일관성 및 유지보수성을 보장하기 위한 개발 가이드라인을 정의합니다. 모든 프로젝트 참여자는 이 가이드라인을 숙지하고 준수해야 합니다.\n\n## 1. 프로젝트 개요\n\n'월말정산 자동화 대시보드'는 뱅크샐러드 엑셀 파일을 업로드하여 공용 지출 내역을 자동 추출하고, 사용자가 설정한 월급 및 고정 지출액을 바탕으로 가족 계좌에 이체할 최종 금액을 계산해주는 개인용 서버리스 웹 애플리케이션입니다. 수동 정산 시간을 30분에서 5분 이내로 단축하는 것을 목표로 합니다.\n\n**핵심 기술 스택:**\n*   **통합 프레임워크:** Next.js 14+ (App Router)\n*   **배포/실행 환경:** Vercel (서버리스 함수)\n*   **데이터베이스 & BaaS:** Supabase (PostgreSQL, 인증, API)\n*   **UI:** Shadcn/ui (Tailwind CSS, Radix UI 기반)\n*   **핵심 라이브러리:** `@supabase/supabase-js`, `jszip`, `xlsx`, `swr` (또는 `react-query`)\n\n**핵심 아키텍처 결정:**\n*   **서버리스 아키텍처:** Vercel과 Supabase를 활용한 완전 서버리스 구성으로 확장성과 운영 효율성을 확보합니다.\n*   **Next.js App Router:** 프론트엔드와 백엔드 API를 통합 관리하여 개발 생산성을 높입니다.\n*   **Edge Network 활용:** Vercel의 글로벌 엣지 네트워크를 통해 빠른 페이지 로딩 속도를 제공합니다.\n*   **Row Level Security (RLS):** Supabase RLS를 통해 사용자별 데이터 접근을 엄격히 통제합니다.\n\n## 2. 핵심 원칙\n\n1.  **명확성 (Clarity):** 코드는 작성자의 의도를 명확하게 드러내야 하며, 주석 없이도 이해하기 쉬워야 합니다.\n2.  **일관성 (Consistency):** 프로젝트 전반에 걸쳐 동일한 코딩 스타일, 명명 규칙 및 패턴을 유지해야 합니다.\n3.  **모듈성 (Modularity):** 각 코드는 단일 책임 원칙을 준수하며, 재사용 가능하고 테스트하기 쉬운 작은 단위로 구성되어야 합니다.\n4.  **성능 최적화 (Performance Optimization):** 사용자 경험을 최우선으로 고려하여, 불필요한 렌더링이나 API 호출을 최소화해야 합니다.\n5.  **보안 우선 (Security First):** 모든 코드 작성 시 잠재적인 보안 취약점을 고려하고, 안전한 코딩 관행을 준수해야 합니다.\n\n## 3. 언어별 가이드라인\n\n### 3.1. 파일 구성 및 디렉토리 구조\n\n**MUST:**\n*   Next.js App Router의 권장 디렉토리 구조를 따릅니다.\n*   컴포넌트는 `components` 디렉토리 내에 기능별 또는 도메인별로 그룹화합니다.\n*   API 라우트는 `app/api` 디렉토리 내에 기능별로 하위 디렉토리를 생성하여 관리합니다.\n*   유틸리티 함수는 `lib` 디렉토리 내에, 타입 정의는 `types` 디렉토리 내에 저장합니다.\n*   Supabase 관련 클라이언트 코드는 `lib/supabase` 디렉토리 내에 통합하여 관리합니다.\n\n```\n.\n├── app/\n│   ├── (main)/\n│   │   ├── page.tsx\n│   │   └── layout.tsx\n│   ├── api/\n│   │   ├── upload/\n│   │   │   └── route.ts\n│   │   ├── expenses/\n│   │   │   └── route.ts\n│   │   └── history/\n│   │       └── route.ts\n│   ├── settings/\n│   │   └── page.tsx\n│   └── history/\n│       └── page.tsx\n├── components/\n│   ├── ui/             # shadcn/ui 컴포넌트 (CLI로 추가)\n│   ├── common/         # 공통적으로 사용되는 컴포넌트 (예: Header, Footer)\n│   └── dashboard/      # 대시보드 관련 컴포넌트 (예: ExpenseList, CalculationSummary)\n├── lib/\n│   ├── utils.ts        # 공통 유틸리티 함수\n│   ├── supabase/\n│   │   ├── client.ts   # Supabase 클라이언트 인스턴스\n│   │   └── server.ts   # Supabase 서버 클라이언트 인스턴스 (API Route용)\n│   ├── parsers.ts      # 엑셀 파싱 로직\n│   └── constants.ts    # 상수 정의\n├── types/\n│   └── index.d.ts      # TypeScript 타입 정의\n├── public/\n└── ...\n```\n\n**MUST NOT:**\n*   `app` 디렉토리 내에 비즈니스 로직이 포함된 유틸리티 파일을 직접 생성하지 않습니다.\n*   단일 파일에 너무 많은 기능을 담지 않습니다. (예: `app/api/all-features.ts`)\n\n### 3.2. 임포트/의존성 관리\n\n**MUST:**\n*   절대 경로 임포트를 사용합니다. (`tsconfig.json`의 `paths` 설정 활용)\n*   외부 라이브러리 임포트, 내부 모듈 임포트 순으로 정렬하고, 각 그룹 사이에 한 줄 공백을 둡니다.\n\n```typescript\n// MUST: 절대 경로 임포트 및 정렬\nimport React from 'react';\nimport { Button } from '@/components/ui/button';\nimport { fetchExpenses } from '@/lib/api';\nimport { Expense } from '@/types';\n\n// ...\n```\n\n**MUST NOT:**\n*   상대 경로 임포트를 남용하여 가독성을 저해하지 않습니다. (예: `../../../components/ui/button`)\n\n### 3.3. 에러 처리 패턴\n\n**MUST:**\n*   **백엔드 (Next.js API Route):**\n    *   `try-catch` 블록을 사용하여 비동기 작업의 에러를 명확히 처리합니다.\n    *   사용자에게 의미 있는 에러 메시지와 적절한 HTTP 상태 코드를 반환합니다.\n    *   `console.error`를 사용하여 서버 로그에 상세 에러를 기록합니다.\n```typescript\n// MUST: API Route 에러 처리\nimport { NextResponse } from 'next/server';\n\nexport async function POST(request: Request) {\n  try {\n    // ... 로직 수행 ...\n    return NextResponse.json({ message: '성공적으로 처리되었습니다.' }, { status: 200 });\n  } catch (error) {\n    console.error('API 처리 중 에러 발생:', error);\n    // 사용자에게 보여줄 에러 메시지는 구체적이지 않게, 내부 에러는 로그로\n    return NextResponse.json({ message: '파일 처리 중 오류가 발생했습니다.' }, { status: 500 });\n  }\n}\n```\n\n*   **프론트엔드:**\n    *   API 호출 시 `try-catch` 또는 `swr`/`react-query`의 에러 핸들링 기능을 활용합니다.\n    *   `shadcn/ui`의 `useToast` 훅과 `Toaster` 컴포넌트를 사용하여 사용자에게 직관적인 에러 메시지를 표시합니다.\n    *   데이터 로딩 실패 시, 사용자에게 빈 상태(empty state) 메시지를 표시합니다.\n\n```typescript\n// MUST: 프론트엔드 에러 처리 (useToast 활용)\nimport { useToast } from '@/components/ui/use-toast';\nimport useSWR from 'swr';\nimport { fetcher } from '@/lib/utils'; // fetcher 함수 예시\n\nfunction MyComponent() {\n  const { toast } = useToast();\n  const { data, error } = useSWR('/api/expenses', fetcher);\n\n  if (error) {\n    toast({\n      title: '데이터 로딩 실패',\n      description: error.message || '지출 내역을 불러오는데 실패했습니다.',\n      variant: 'destructive',\n    });\n    return <div>지출 내역을 불러올 수 없습니다.</div>;\n  }\n\n  // ... 데이터 렌더링 ...\n}\n```\n\n**MUST NOT:**\n*   에러를 단순히 `console.log`로만 출력하고 사용자에게 아무런 피드백을 주지 않습니다.\n*   백엔드에서 민감한 에러 스택 트레이스를 클라이언트에 직접 노출하지 않습니다.\n\n## 4. 코드 스타일 규칙\n\n### 4.1. MUST Follow (필수 준수 사항)\n\n*   **TypeScript 사용:** 모든 코드에 TypeScript를 사용하여 타입 안정성을 확보합니다. `any` 타입 사용은 최소화하고 명확한 타입 정의를 선호합니다.\n*   **ESLint 및 Prettier:** 프로젝트에 설정된 ESLint 및 Prettier 규칙을 준수합니다. 커밋 전 자동 포맷팅을 권장합니다.\n*   **명명 규칙:**\n    *   변수, 함수: `camelCase` (예: `expenseList`, `calculateTotalAmount`)\n    *   컴포넌트: `PascalCase` (예: `ExpenseItem`, `DashboardLayout`)\n    *   상수: `SCREAMING_SNAKE_CASE` (예: `API_BASE_URL`, `MAX_FILE_SIZE`)\n    *   파일 이름: `kebab-case` (예: `expense-list.tsx`, `api-client.ts`)\n*   **주석:**\n    *   복잡한 로직이나 비즈니스 규칙에 대한 설명은 주석으로 명확히 작성합니다.\n    *   JSDoc 스타일 주석을 사용하여 함수, 컴포넌트, 타입의 목적, 인자, 반환 값 등을 설명합니다.\n    *   불필요하거나 자명한 주석은 작성하지 않습니다.\n*   **단일 책임 원칙 (SRP):** 함수, 컴포넌트, 모듈은 하나의 명확한 책임만 가져야 합니다.\n*   **가독성:**\n    *   한 줄에 80~120자 제한을 지키도록 노력합니다.\n    *   적절한 공백과 줄 바꿈을 사용하여 코드 블록을 구분합니다.\n    *   조건문, 반복문 등은 중첩을 최소화하고 조기 반환(early return)을 적극 활용합니다.\n\n```typescript\n// MUST: 명확한 함수명, JSDoc 주석, 조기 반환\n/**\n * 주어진 지출 목록에서 체크된 항목들의 총 금액을 계산합니다.\n * @param expenses - 지출 항목 배열\n * @returns 체크된 항목들의 총 금액\n */\nfunction calculateCheckedExpensesTotal(expenses: Expense[]): number {\n  if (!expenses || expenses.length === 0) {\n    return 0;\n  }\n\n  return expenses.reduce((sum, expense) => {\n    if (expense.isChecked) {\n      return sum + expense.amount;\n    }\n    return sum;\n  }, 0);\n}\n```\n\n### 4.2. MUST NOT Do (피해야 할 사항)\n\n*   **거대한 단일 파일:** 단일 파일에 너무 많은 컴포넌트, 함수, 비즈니스 로직을 몰아넣지 않습니다. 모듈성을 해치고 유지보수를 어렵게 만듭니다.\n*   **복잡한 상태 관리:** `useState`와 `useReducer`로 충분한 경우, 불필요하게 복잡한 전역 상태 관리 라이브러리(예: Redux)를 도입하지 않습니다. `swr` 또는 `react-query`를 사용하여 서버 상태를 효율적으로 관리합니다.\n*   **매직 넘버/문자열:** 코드 내에 의미를 알 수 없는 숫자나 문자열 리터럴을 직접 사용하지 않고, 상수로 정의하여 사용합니다.\n*   **직접적인 DOM 조작:** React 컴포넌트 내에서 `document.getElementById`와 같은 직접적인 DOM 조작은 피하고, React의 상태 관리 및 참조(ref) 시스템을 활용합니다.\n*   **불필요한 렌더링:** `React.memo`, `useCallback`, `useMemo`를 적절히 사용하여 불필요한 컴포넌트 리렌더링을 방지하고 성능을 최적화합니다. 하지만 과도한 사용은 오히려 복잡성을 증가시키므로 신중하게 적용합니다.\n\n```javascript\n// MUST NOT: 거대한 단일 파일 (예시)\n// 이 파일은 너무 많은 책임을 가집니다.\n// components/dashboard/ExpenseList.tsx, components/dashboard/CalculationSummary.tsx 등으로 분리해야 합니다.\n// export function ExpenseList() { /* ... */ }\n// export function CalculationSummary() { /* ... */ }\n// export function SettingsForm() { /* ... */ }\n// export function ApiUtils() { /* ... */ }\n```\n\n```typescript\n// MUST NOT: 매직 넘버 사용\n// if (status === 1) { /* ... */ } // 1의 의미가 불분명\n//\n// MUST: 상수로 정의하여 사용\n// const EXPENSE_STATUS_CONFIRMED = 1;\n// if (status === EXPENSE_STATUS_CONFIRMED) { /* ... */ }\n```\n\n## 5. 아키텍처 패턴\n\n### 5.1. 컴포넌트/모듈 구조 가이드라인\n\n**MUST:**\n*   **원자적 컴포넌트:** `shadcn/ui` 컴포넌트는 원자적(atomic)으로 사용하고, 이를 조합하여 더 큰 컴포넌트를 만듭니다.\n*   **컨테이너/프리젠테이션 패턴:** 데이터 로딩 및 비즈니스 로직을 담당하는 컨테이너 컴포넌트와 UI 렌더링만 담당하는 프리젠테이션 컴포넌트를 분리하여 관리합니다. (Next.js 서버 컴포넌트/클라이언트 컴포넌트 구분을 활용)\n*   **서버 컴포넌트 우선:** 가능한 한 서버 컴포넌트를 사용하여 초기 로딩 성능을 최적화하고, 클라이언트 상호작용이 필요한 부분만 `use client` 지시어를 사용하여 클라이언트 컴포넌트로 분리합니다.\n\n```typescript\n// MUST: 서버 컴포넌트 (데이터 페칭 및 로직)\n// app/dashboard/page.tsx\nimport { createServerComponentClient } from '@supabase/auth-helpers-nextjs';\nimport { cookies } from 'next/headers';\nimport { ExpenseListClient } from '@/components/dashboard/ExpenseListClient'; // 클라이언트 컴포넌트 임포트\n\nexport default async function DashboardPage() {\n  const supabase = createServerComponentClient({ cookies });\n  const { data: expenses, error } = await supabase.from('shared_expenses').select('*');\n\n  if (error) {\n    console.error('지출 내역 로딩 실패:', error);\n    return <div>데이터를 불러오는데 실패했습니다.</div>;\n  }\n\n  return (\n    <div>\n      <h1>월말 정산 대시보드</h1>\n      <ExpenseListClient initialExpenses={expenses || []} />\n    </div>\n  );\n}\n\n// MUST: 클라이언트 컴포넌트 (UI 상호작용 및 상태 관리)\n// components/dashboard/ExpenseListClient.tsx\n'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Input } from '@/components/ui/input';\nimport { Expense } from '@/types';\n\ninterface ExpenseListClientProps {\n  initialExpenses: Expense[];\n}\n\nexport function ExpenseListClient({ initialExpenses }: ExpenseListClientProps) {\n  const [expenses, setExpenses] = useState<Expense[]>(initialExpenses.map(exp => ({\n    ...exp,\n    isChecked: false,\n    currentMemo: exp.memo || '',\n  })));\n\n  // ... 체크박스 및 메모 변경 로직 ...\n\n  return (\n    <Table>\n      <TableHeader>\n        <TableRow>\n          <TableHead>선택</TableHead>\n          <TableHead>날짜</TableHead>\n          <TableHead>내용</TableHead>\n          <TableHead>금액</TableHead>\n          <TableHead>메모</TableHead>\n        </TableRow>\n      </TableHeader>\n      <TableBody>\n        {expenses.map((expense) => (\n          <TableRow key={expense.id}>\n            <TableCell>\n              <Checkbox\n                checked={expense.isChecked}\n                onCheckedChange={(checked) => { /* ... */ }}\n              />\n            </TableCell>\n            <TableCell>{expense.expense_date}</TableCell>\n            <TableCell>{expense.content}</TableCell>\n            <TableCell>{expense.amount.toLocaleString()}원</TableCell>\n            <TableCell>\n              <Input\n                value={expense.currentMemo}\n                onChange={(e) => { /* ... */ }}\n              />\n            </TableCell>\n          </TableRow>\n        ))}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n**MUST NOT:**\n*   클라이언트 컴포넌트 내에서 불필요하게 서버 데이터를 직접 페칭하지 않습니다. (가능한 경우 서버 컴포넌트에서 페칭 후 prop으로 전달)\n*   UI 로직과 비즈니스 로직이 한 컴포넌트에 뒤섞여 복잡성을 증가시키지 않습니다.\n\n### 5.2. 데이터 흐름 패턴\n\n**MUST:**\n*   **단방향 데이터 흐름:** React의 단방향 데이터 흐름 원칙을 준수합니다. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하고, 자식 컴포넌트의 이벤트는 콜백 함수를 통해 부모에게 전달합니다.\n*   **서버 상태 관리:** `swr` 또는 `react-query`를 사용하여 서버에서 가져온 데이터(지출 내역, 설정 등)를 캐싱하고 동기화합니다. 이를 통해 불필요한 API 호출을 줄이고 UI 응답성을 높입니다.\n*   **클라이언트 상태 관리:** UI 관련 임시 상태(예: 모달 열림/닫힘, 입력 필드 값)는 `useState`를 사용하여 컴포넌트 내에서 관리합니다.\n\n### 5.3. 상태 관리 컨벤션\n\n**MUST:**\n*   **로컬 상태:** 컴포넌트 내부에서만 사용되는 상태는 `useState` 또는 `useReducer`를 사용합니다.\n*   **서버 캐시 상태:** API를 통해 가져오는 데이터는 `swr` 또는 `react-query`의 훅을 사용하여 관리합니다. (예: `useSWR('/api/expenses', fetcher)`)\n*   **전역 상태 (최소화):** 전역적으로 공유되어야 하는 상태(예: 사용자 인증 정보 - 향후 확장 시)는 React Context API나 가벼운 전역 상태 관리 라이브러리(예: Zustand)를 신중하게 고려하여 사용합니다. 현재 프로젝트 범위에서는 `swr` 또는 `react-query`의 전역 캐시만으로 충분합니다.\n\n```typescript\n// MUST: swr을 이용한 서버 상태 관리\nimport useSWR from 'swr';\nimport { fetcher } from '@/lib/utils'; // axios 또는 fetch 기반의 fetcher 함수\n\ninterface Expense { /* ... */ }\n\nfunction ExpensesDisplay() {\n  const { data: expenses, error, isLoading, mutate } = useSWR<Expense[]>('/api/expenses?startDate=...&endDate=...', fetcher);\n\n  if (isLoading) return <div>로딩 중...</div>;\n  if (error) return <div>에러 발생: {error.message}</div>;\n\n  const handleUpdateExpense = async () => {\n    // ... API 호출로 데이터 업데이트 ...\n    await mutate(); // 데이터 갱신\n  };\n\n  return (\n    // ... expenses 데이터 렌더링 ...\n  );\n}\n```\n\n**MUST NOT:**\n*   `props drilling`을 피하기 위해 불필요하게 Context API를 남용하지 않습니다.\n*   복잡한 상태 로직을 `useState` 하나로 관리하려 하지 않고, `useReducer`를 고려합니다.\n\n### 5.4. API 디자인 표준\n\n**MUST:**\n*   **RESTful 원칙:** API 엔드포인트는 RESTful 원칙을 따르도록 설계합니다. (예: `/api/expenses`, `/api/history`)\n*   **명확한 응답:** API 응답은 성공/실패 여부, 메시지, 데이터 등을 포함하여 클라이언트가 쉽게 처리할 수 있도록 명확하게 구성합니다.\n*   **HTTP 상태 코드:** 응답에 적절한 HTTP 상태 코드를 사용합니다 (예: 200 OK, 201 Created, 400 Bad Request, 404 Not Found, 500 Internal Server Error).\n*   **보안:**\n    *   Supabase RLS를 통해 데이터 접근 권한을 제어합니다.\n    *   민감 정보는 환경 변수를 통해 관리하고, 클라이언트에 노출되지 않도록 합니다.\n    *   API Route에서 Supabase Admin 클라이언트를 사용할 때는 `SUPABASE_SERVICE_ROLE_KEY`를 사용하고, 클라이언트에서 사용할 때는 `NEXT_PUBLIC_SUPABASE_ANON_KEY`를 사용합니다.\n\n```typescript\n// MUST: API Route 응답 예시\nimport { NextResponse } from 'next/server';\nimport { createServerClient } from '@supabase/ssr'; // 서버용 Supabase 클라이언트\n\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const startDate = searchParams.get('startDate');\n  const endDate = searchParams.get('endDate');\n\n  if (!startDate || !endDate) {\n    return NextResponse.json({ message: '시작일과 종료일은 필수입니다.' }, { status: 400 });\n  }\n\n  try {\n    const supabase = createServerClient({ /* ... */ }); // 서버용 클라이언트 초기화\n    const { data: expenses, error } = await supabase\n      .from('shared_expenses')\n      .select('*')\n      .gte('expense_date', startDate)\n      .lte('expense_date', endDate);\n\n    if (error) {\n      console.error('지출 내역 조회 에러:', error);\n      return NextResponse.json({ message: '데이터 조회 중 오류가 발생했습니다.' }, { status: 500 });\n    }\n\n    return NextResponse.json(expenses, { status: 200 });\n  } catch (error) {\n    console.error('API 처리 중 예외 발생:', error);\n    return NextResponse.json({ message: '서버 오류가 발생했습니다.' }, { status: 500 });\n  }\n}\n```\n\n**MUST NOT:**\n*   API 엔드포인트 이름이 동사를 포함하지 않도록 합니다. (예: `/api/getExpenses` 대신 `/api/expenses`)\n*   에러 발생 시 단순한 문자열 대신 구조화된 JSON 응답을 반환합니다.",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-09-19T14:27:07.913Z"
    },
    {
      "type": "isms-p",
      "content": "\n# ISMS-P Based Secure Development Rules (v1.0)\n# This document defines the mandatory security rules for developers during code implementation.\n# Reference: Based on the Information Security Management System - Personal Information (ISMS-P) standard.\n\n## 1. Authentication & Authorization\n- **(A-1) User Identification and Authentication**\n  - **MUST**: Every user must be individually identifiable. The use of shared accounts is prohibited.\n  - **MUST**: Passwords MUST satisfy one of the following policies:\n    - (a) 8+ characters with a mix of letters, numbers, and special characters.\n    - (b) 10+ characters with a mix of letters and numbers.\n  - **MUST**: An account lockout policy MUST be implemented for failed login attempts (e.g., lock the account for 5 minutes after 5 consecutive failures).\n\n- **(A-2) Management of Authentication Credentials**\n  - **MUST**: Authentication credentials such as passwords MUST be stored using an adaptive hash function like **bcrypt, scrypt, or Argon2**. (Using SHA-256 alone is prohibited).\n\n- **(A-3) Privilege Management**\n  - **MUST**: Grant only the minimum necessary privileges for a role, following the **Principle of Least Privilege**.\n  - **MUST**: All actions of granting, changing, and revoking privileges MUST be logged.\n\n- **(A-4) Privileged Access Management**\n  - **MUST**: Administrative privileges (e.g., root, admin) MUST be granted to a minimum number of users, and the reason for using such accounts MUST be clearly logged.\n  - **SHOULD**: Administrative accounts SHOULD be separate from regular user accounts.\n\n## 2. Access Control\n- **(AC-1) System Access**\n  - **MUST**: Access to information systems by unauthorized users MUST be blocked.\n  - **MUST**: Access logs for critical systems MUST be retained for **at least one year**.\n\n- **(AC-2) Network Access**\n  - **MUST**: Public-facing services MUST be located in a **DMZ**, separate from the internal network.\n  - **MUST**: Firewalls MUST allow only the minimum necessary ports required for the service. (Prohibit \"allow all\" rules).\n\n## 3. Cryptography\n- **(C-1) Encryption of Sensitive Information**\n  - **MUST**: Legally defined sensitive information (e.g., national ID numbers, passport numbers, bank account numbers, credit card numbers) and passwords MUST be encrypted during storage and transmission.\n  - **MUST**: Use secure and vetted cryptographic algorithms such as **AES-256**.\n  - **MUST NOT**: Do not use homegrown or custom-developed cryptographic algorithms.\n\n- **(C-2) Cryptographic Key Management**\n  - **MUST NOT**: Do not hardcode cryptographic keys in source code, configuration files, or comments.\n  - **MUST**: Cryptographic keys MUST be managed securely using **environment variables** or a dedicated **Key Management System (KMS, HSM)**.\n  - **MUST**: Minimize access to keys and log all lifecycle management procedures, including generation, use, and destruction.\n\n## 4. Secure Development\n- **(D-1) Secure Design**\n  - **MUST**: Defense mechanisms against major vulnerabilities like the **OWASP Top 10** (e.g., SQL Injection, XSS, CSRF) MUST be incorporated during the design phase.\n\n- **(D-2) Secure Coding**\n  - **MUST**: Treat all external input (e.g., request parameters, headers, cookies) as untrusted. **Validation and sanitization** logic MUST always be applied.\n  - **MUST**: All SQL queries MUST use **parameterized queries (prepared statements)**. (Dynamic query string concatenation is prohibited).\n  - **MUST**: When handling errors, ensure that internal system details (e.g., stack traces, database information) are not exposed to the user.\n\n- **(D-3) Security Testing**\n  - **SHOULD**: Periodically scan for security vulnerabilities using static/dynamic analysis tools (**SAST/DAST**).\n\n## 5. Personal Information Handling\n- **(P-1) Collection and Use**\n  - **MUST**: Collect only the minimum personal information necessary to provide the service. The purpose of collection MUST be clearly disclosed to users, and consent must be obtained.\n  - **MUST NOT**: Do not process sensitive information (e.g., beliefs, ideology) or unique identification information without a legal basis or separate user consent.\n\n- **(P-2) Storage and Display**\n  - **MUST**: Personal information MUST be **masked** when displayed on screen (e.g., John D**, +1-***-***-1234, test@****.com).\n  - **MUST NOT**: Do not use personal information or provide it to third parties beyond the scope of the consented purpose.\n\n- **(P-3) Destruction**\n  - **MUST**: When the retention period expires or the processing purpose is achieved, personal information MUST be completely destroyed using an irreversible method.\n  - **MUST**: Establish a personal information destruction procedure and maintain a log of all destructions.\n\n## 6. Logging & Management\n- **(L-1) Log Recording**\n  - **MUST**: Logs for critical activities (e.g., login, access to personal information, privilege changes) MUST be securely retained for **at least one year**.\n  - **MUST**: Logs MUST be standardized and include at least the following: [Timestamp, User ID, Source IP Address, Request/Action, Success/Failure Status].\n",
      "writedAt": "2025-09-19T14:27:07.913Z"
    }
  ]
}